# 오브젝트와 의존관계

## 자바 빈(Java Bean)
자바의 주력 개발 플랫폼이 웹 기반의 엔터프라이즈 방식으로 바뀌면서 비주얼 컴포넌트로서 자바빈은 인기를 잃었지만, 자바빈의 몇가지 코딩 관례는 JSP 빈, EJB와 같은 표준 기술과 자바빈 스타일의 오브젝트를 사용하는 오픈소스 기술을 통해 계속 이어져 왔다.
- 디폴트 생성자: 자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다.
- 프로퍼티: 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다. set으로 시작하는 수정자와 get으로 시작하는 접근자를 이용해 수정 또는 조회가 가능하다.

개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 바로 미래의 변화를 어떻게 대비할 것인가 이다.  
객체지향이 절차지향에 비해 개발 초기에 번거로운 작업을 요구하는 이유는 객체지향 기술 자체가 지니는, 변화에 효과적으로 대처 할 수 있다는 특징 때문이다.  

## 템플릿 메소드 패턴
상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법이다.  
변하지 않는 기능은 슈퍼클래스에 만들어두고 자주 변경되며 학장할 기능은 서브클래스에서 만들도록 한다.  
슈퍼클래스에서는 미리 추상 메소드 또는 오버라이드 가능한 메소드를 정의해두고 이를 활용해 코드의 기본 알고리즘을 담고 있는 템플릿 메소드를 만든다.  
서브클래스에서는 추상 메소드를 구현하거나, 메소드를 오버라이드하는 방법을 이용해 기능의 일부를 확장한다.  

## 팩토리 메소드 패턴
팩토리 메소드 패턴도 템플릿 메소드 패턴과 마찬가지로 상속을 통해 기능을 확장하게 하는 패턴이다.  
그래서 구조도 비슷하다. 슈퍼 클래스 코드에서는 서브 클래스에서 구현할 메소드를 호출해서 필요한 타입의 오브젝트를 가져와 사용한다.  
서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드를 팩토리 메소드라고 하고, 이 방식을 통해 오브젝트 생성 방법을 나머지 로직, 즉 슈퍼클래스의 기본 코드에서 독립시키는 방법을 팩토리 메소드 패턴이라고 한다.

## 원칙과 패턴

### 개방 폐쇄 원칙(OCP, Open Closed Principle)
개팡 폐쇄 원칙은 깔끔한 설계를 위해 적용 가능한 객체지향 설계 원칙 중의 하나다. 이 원칙을 간단히 정의하자면 클래스나 모듈은 확장에는 열려있어야 하고 변경에는 닫혀 있어야 한다 라고 할 수 있다.  

### 높은 응집도와 낮은 결합도
개방 폐쇄 원칙은 높은 응집도와 낮은 결합도 라는 소프트웨어 개발의 고전적인 원리로도 설명이 가능하다.  
응집도가 높다는건 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다. 불필요하거나 직접 관련이 없는 외부의 관심과 책임이 얽혀 있지 않으며, 하나의 공통 관심사는 한 클래스에 모여있다.  
그 크기는 다르더라도 동일한 원리로 적용이 가능하다.

### 전략 패턴(Strategy Pattern)
전략 패턴은 디자인 패턴의 꽃이라고 불릴 만큼 가장 자주, 다양하게 사용되는 패턴이다. 개방 폐쇄 원칙의 실현에도 가장 잘 들어맞는 패턴이라고 볼 수 있다. 전략 패턴은 자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.  
여기서 말하는 알고리즘은 수학적 알고리즘이 아닌, 독립적인 책임으로 분리가 가능한 기능을 뜻한다.

## 제어의 역전(IoC)
IoC라는 약자로 많이 사용되는 제어의 역전이라는 용어가 있다. 스프링을 통해 일반 개발자에게는 많이 알려진 용어이지만, 이 제어의 역전이라는 개념은 상당히 오래전 부터 있었다.

### 오브젝트 팩토리
오브젝트 팩토리는 객체 생성의 책임을 담당하는 별도의 클래스이다.  
객체를 어떻게 만들고 연결할지에 대한 관심사를 분리하기 위해 사용한다.  
여기서도 문제가 있다. 왜냐하면 오브젝트 팩토리는 클라이언트가 직접 작성해야되기 때문이다. 만약 각 객체가 필요로하는 의존성이 변경되면? 명시적으로 new를 통해 선언해서 할당했기 때문에 변경해주는 작업이 필요하다.  

### DI Container
스프링에는 DI Container가 존재하는데, 이 컨테이너는 오브젝트 팩토리를 넘어서 추가적인 기능을 가진다.  
DI Container는 설계도를 넘어서 주입하는 과정 까지도 담당해서 진행한다. 재귀적으로 생성자를 호출하여 필요한 오브젝트가 존재하지 않으면, 생성하고 빈으로 저장하여 싱글톤으로 유지하고 주입한다.
구현채로는 ApplicationContext가 존재함.

## 스프링을 굳이 사용하지 않고 DaoFactory를 만들어서 사용하면 안되나?
왜냐하면 기능적으로 다를바가 없기 때문이다. getBean 메서드를 통해 호출해서 원하는 오브젝트를 찾아오는데 이것을 사용하기 위해 굳이 스프링이라는 무거운 라이브러리를 가져올 필요가 있나?
아니다. 스프링은 간단한 구현으로 만들었던 DaoFactory보다 더 방대한 기능을 가지고 있다.

## ApplicationContext
ApplicationContext는 BeanFactory 인터페이스를 상속했으므로 애플리케이션 컨텍스트는 일종의 빈 팩토리이다.
스프링의 가장 대표되는 오브젝트이고, 좀 과하게는 애플리케이션 컨텍스트 = 스프링 이라고 생각하는 개발자도 있다고한다.
클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다. DaoFactory는 오브젝트가 추가될 때 마다 계속 생성해줘야된다. 클라이언트가 직접.
어플리케이션 컨텍스트는 그럴 필요가없다. xml같은 단순한 방법을 사용해 IoC 설정 정보를 만들 수도 있다.
단지 오브젝트 생성 및 관계설정이 아니라, 만들어지는 방식과 시점 전략을 다르게 가져갈 수도 있다. 오브젝트 후처리, 정보의 조합 등 다양한 기능을 제공한다.
빈이 사용할 수 있는 기반기술 서비스나 외부 시스템과의 연동등을 컨테이너 차원에서 제공하기도 한다.
getBean을 넘어서 타입으로 빈을 검색하는 등 다양한 추가 기능을 내포한다.

## 스프링 IoC 용어 정리

### 빈(Bean)
스프링이 IoC방식으로 관리하는 오브젝트라는 의미, 관리되는 오브젝트로도 불린다. 스프링이 직접 생성과 제어를 담당하는 객체가 빈이다.

### 빈 팩토리(Bean Factory)
스프링의 IoC를 담당하는 핵심 컨테이너를 가르킨다. 빈을 등록 생성 제어 하는 모든 과정을 빈 팩토리가 담당하고 빈 팩토리는 이대로 사용되지 않고, 어플리케이션 컨텍스트로 확장되어 사용된다.

### 어플리케이션 컨텍스트(Application Context)
빈 팩토리를 확장한 IoC컨테이너 이다. 기본적인 빈 팩토리의 확장된 개념이다. ApplicationContext 인터페이스를 까보면 내부에 BeanFactory가 추상화 되어있음을 알 수 있다.

### 설정정보/메타정보(configuration metadata)
빈 팩토리, 어플리케이션 컨텍스트가 IoC를 적용하기 위해 사용하는 메타정보이다. 구성정보 형상정보 라고도 한다.

### 

























